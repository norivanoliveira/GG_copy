local b=1.52 local c="GGPrediction"if _G.GGPrediction then return end if not FileExist(COMMON_PATH.."GGCore.lua")then if not _G.DownloadingGGCore then DownloadFileAsync("https://raw.githubusercontent.com/gamsteron/GG/master/GGCore.lua",COMMON_PATH.."GGCore.lua",function()end)print('GGCore - downloaded! Please 2xf6!')_G.DownloadingGGCore=true end return end require('GGCore')GGUpdate:New({version=b,scriptName=c,scriptPath=COMMON_PATH..c..".lua",scriptUrl="https://raw.githubusercontent.com/gamsteron/GG/master/"..c..".lua",versionPath=COMMON_PATH.."GGVersion.lua",versionType=0,})_G.GGPrediction=true _G.DownloadingGGPrediction=true local d=math.huge local e=math.pi local f=assert(math.sqrt)local g=assert(math.abs)local h=assert(math.min)local i=assert(math.max)local j=assert(math.pow)local k=assert(math.atan)local l=assert(math.acos)local m=assert(table.remove)local n=assert(table.insert)local o,p,q,r=_G.Game,_G.Vector,_G.Draw,_G.Callback local s,t,u,v,w,x,y,z local A=0 local B=1 local C=2 local D=3 local E=0 local F=1 local G=2 local H=3 local I=4 local J=0 local K=1 local L=2 local M=MenuElement({name="GG Prediction",id="GGPrediction",type=_G.MENU})s={MaxRange=M:MenuElement({id="PredMaxRange"..myHero.charName,name="Pred Max Range %",value=100,min=70,max=100,step=1}),Latency=M:MenuElement({id="Latency",name="Ping/Latency",value=50,min=0,max=200,step=5}),ExtraDelay=M:MenuElement({id="ExtraDelay",name="Extra Delay",value=60,min=0,max=100,step=5}),VersionA=M:MenuElement({name='',type=_G.SPACE,id='VersionSpaceA'}),VersionB=M:MenuElement({name='Version  '..b,type=_G.SPACE,id='VersionSpaceB'}),}function s:GetMaxRange()local N=self.MaxRange:Value()*0.01 return N end function s:GetLatency()local N=self.Latency:Value()*0.001 return N end function s:GetExtraDelay()local N=self.ExtraDelay:Value()*0.001 return N end t={IMMOBILE_TYPES={[5]=true,[8]=true,[12]=true,[22]=true,[23]=true,[25]=true,[30]=true,},}function t:GetDuration(N)local O=0 local P=0 local Q=0 local R=0 if N.pathing.hasMovePath then return Q,O,P,R end local S=SDK.BuffManager:GetBuffs(N)for U=1,#S do local V=S[U]local W=V.duration if W>0 then if W>Q and self.IMMOBILE_TYPES[V.type]then Q=W elseif V.type==31 then R=W end end end local T=N.activeSpell if T and T.valid then if T.isAutoAttack then P=T.castEndTime elseif T.windup>0.1 then O=T.castEndTime end end return Q,O,P,R end u={}function u:Get2D(N)N=N.pos==nil and N or N.pos return{x=N.x,z=N.z==nil and N.y or N.z}end function u:Get3D(N)local O=p(N.x,0,N.z)return O end function u:GetDistance(N,O)local P=O.x-N.x local Q=O.z-N.z return f(P*P+Q*Q)end function u:IsInRange(N,O,P)local Q=N.x-O.x local R=N.z-O.z if(Q*Q+R*R<=P*P)then return true end return false end function u:VectorsEqual(N,O,P)P=P or 5 if(self:GetDistance(N,O)<P)then return true end return false end function u:Normalized(N,O)local P=N.x-O.x local Q=N.z-O.z local R=f(P*P+Q*Q)local S=nil if(R>0)then local T=1.0/R S={x=(P*T),z=(Q*T)}end return S end function u:Extended(N,O,P)if(O==nil)then return N end return{x=N.x+O.x*P,z=N.z+O.z*P}end function u:Perpendicular(N)if(N==nil)then return nil end return{x=-N.z,z=N.x}end function u:Intersection(N,O,P,Q)local R={Intersects=false,Point={x=0,z=0}}local S=N.z-P.z local T=Q.x-P.x local U=N.x-P.x local V=Q.z-P.z local W=O.x-N.x local X=O.z-N.z local Y=W*V-X*T local Z=S*T-U*V if(Y==0)then if(Z==0)then if N.x>=P.x and N.x<=Q.x then return{Intersects=true,Point=N}end if P.x>=N.x and P.x<=O.x then return{Intersects=true,Point=P}end return R end return R end local ab=Z/Y if(ab<0 or ab>1)then return R end local bb=(S*W-U*X)/Y if(bb<0 or bb>1)then return R end local cb={x=N.x+ab*W,z=N.z+ab*X}return{Intersects=true,Point=cb}end function u:ClosestPointOnLineSegment(N,O,P)local Q=N.x local R=N.z local S=O.x local T=O.z local U=P.x local V=P.z local W=U-S local X=V-T local Y=((Q-S)*W+(R-T)*X)/(W*W+X*X)if(Y<0)then return O,false end if(Y>1)then return P,false end return{x=S+Y*W,z=T+Y*X},true end function u:Intercept(N,O,P,Q,R)local S=P.x-O.x local T=P.z-O.z local U=f(S*S+T*T)local V=O.x-N.x local W=O.z-N.z local X=(S/U)*R local Y=(T/U)*R local Z=X*X+Y*Y-Q*Q local ab=2*(X*V+Y*W)local bb=V*V+W*W local cb if(g(Z)<1e-6)then if(g(ab)<1e-6)then if(g(bb)<1e-6)then cb={0,0}end else cb={-bb/ab,-bb/ab}end else local eb=ab*ab-4*Z*bb if(eb>=0)then eb=f(eb)local fb=2*Z cb={(-ab-eb)/fb,(-ab+eb)/fb}end end local db if(cb)then local eb=cb[1]local fb=cb[2]local gb=h(eb,fb)if(gb<0)then gb=i(eb,fb)end if(gb>0)then db=gb end end return db end function u:Polar(N)local O=N.x local P=N.z if(O==0)then if(P>0)then return 90 end if(P<0)then return 270 end return 0 end local Q=k(P/O)*(180.0/e)if(O<0)then Q=Q+180 end if(Q<0)then Q=Q+360 end return Q end function u:AngleBetween(N,O)if(N==nil or O==nil)then return nil end local P=self:Polar(N)-self:Polar(O)if(P<0)then P=P+360 end if(P>180)then P=360-P end return P end function u:FindAngle(N,O,P)local Q=j(O.x-N.x,2)+j(O.z-N.z,2)local R=j(O.x-P.x,2)+j(O.z-P.z,2)local S=j(P.x-N.x,2)+j(P.z-N.z,2)local T=l((R+Q-S)/f(4*R*Q))*(180/e)if(T>90)then T=180-T end return T end function u:CircleCircleIntersection(N,O,P,Q)local R={}local S=self:GetDistance(N,O)if S>P+Q or S<=g(P-Q)then return R end local T=(P*P-Q*Q+S*S)/(2*S)local U=f(P*P-T*T)local V=self:Normalized(O,N)local W=self:Extended(N,V,T)local X=self:Perpendicular(V)n(R,self:Extended(W,X,U))n(R,self:Extended(W,X,-U))return R end v={}function v:GetLenght(N)local O=0 for P=1,#N-1 do O=O+u:GetDistance(N[P],N[P+1])end return O end function v:CutPath(N,O)local P={}if O<=0 then return N end for Q=1,#N-1 do local R,S=N[Q],N[Q+1]local T=u:GetDistance(R,S)if T>O then n(P,u:Extended(R,u:Normalized(S,R),O))for U=Q+1,#N do n(P,N[U])end break end O=O-T end return#P>0 and P or{N[#N]}end function v:ReversePath(N)local O={}for P=#N,1,-1 do n(O,N[P])end return O end function v:GetPath(N)local O={u:Get2D(N.pos)}local P=N.pathing if P then if P.isDashing then local Q=P.endPos if Q and Q.x then n(O,u:Get2D(Q))else end else local Q=P.pathIndex local R=P.pathCount if Q and R and Q>=0 and R<=20 then for S=Q,R do local T=N:GetPath(S)if T and T.x then n(O,u:Get2D(T))else end end else end end end return O end function v:GetPredictedPath(N,O,P,Q)local R={}local S=0 for T=1,#Q-1 do local U=Q[T]n(R,U)local V=Q[T+1]local W=u:GetDistance(U,V)/P local X=u:Normalized(V,U)U=u:Extended(U,X,-(P*S))local Y=u:Intercept(N,U,V,O,P)if(Y and Y>=S and Y<=S+W)then n(R,u:Extended(U,X,Y*P))return R,Y end S=S+W end return nil,-1 end w={Visible={},Waypoints={},}function w:OnVisible(N,O)if(self.Visible[N]==nil)then self.Visible[N]={visible=O,visibleTick=GetTickCount(),invisibleTick=GetTickCount()}end if O then if not self.Visible[N].visible then self.Visible[N].visible=true self.Visible[N].visibleTick=GetTickCount()end else if self.Visible[N].visible then self.Visible[N].visible=false self.Visible[N].invisibleTick=GetTickCount()end end end function w:OnWaypoint(N,O,P,Q,R)local S=GetTickCount()if self.Waypoints[N]==nil then self.Waypoints[N]={moving=P,dashing=Q,path=O,tick=S,stoptick=S,pos=R}end if P then if not u:VectorsEqual(self.Waypoints[N].pos,R,50)then self.Waypoints[N].tick=S end self.Waypoints[N].pos=R self.Waypoints[N].dashing=Q elseif self.Waypoints[N].moving then self.Waypoints[N].stoptick=GetTickCount()end self.Waypoints[N].path=O self.Waypoints[N].moving=P end function w:OnTick()local N,O,P,Q,R,S,T for U,V in ipairs(x:GetHeroes())do N=V.networkID O=V.visible self:OnVisible(N,O)if O then Q=V.pathing if Q then R=Q.hasMovePath S=Q.isDashing T=u:Get2D(Q.endPos)P=v:GetPath(V)self:OnWaypoint(N,P,R,S,T)end end end end function w:OnPrediction(N)local O=N.networkID local P=N.visible self:OnVisible(O,P)if P then local Q=N.pathing.hasMovePath local R=N.pathing.isDashing local S=u:Get2D(N.pathing.endPos)self:OnWaypoint(O,v:GetPath(N),Q,R,S)end end r.Add('Load',function()r.Add('Draw',function()w:OnTick()end)end)x={}function x:IsValid(N)if N and N.valid and N.visible and not N.dead and N.isTargetable then return true end return false end function x:GetHeroes()local N={}local O,P P=o.HeroCount()for Q=1,P do O=o.Hero(Q)if O and O.valid and not O.dead then n(N,O)end end return N end function x:GetEnemyHeroes()local N={}local O=o.HeroCount()for P=1,O do local Q=o.Hero(P)if self:IsValid(Q)and Q.isEnemy then n(N,Q)end end return N end function x:GetAllyHeroes()local N={}local O=o.HeroCount()for P=1,O do local Q=o.Hero(P)if self:IsValid(Q)and Q.isAlly then n(N,Q)end end return N end y={}function y:GetCollision(N,O,P,Q,R,S,T)N=u:Extended(N,u:Normalized(N,O),75)O=u:Extended(O,u:Normalized(O,N),75)local U,V,W=false,{},0 local X={}for Y,Z in pairs(S)do if(Z==A)then for ab=1,o.MinionCount()do local bb=o.Minion(ab)if(bb.networkID~=T and x:IsValid(bb)and bb.isEnemy and u:GetDistance(N,u:Get2D(bb.pos))<2000)then n(X,bb)end end elseif(Z==B)then for ab,bb in pairs(x:GetAllyHeroes())do if(bb.networkID~=T and u:GetDistance(N,u:Get2D(bb.pos))<2000)then n(X,bb)end end elseif(Z==C)then for ab,bb in pairs(x:GetEnemyHeroes())do if(bb.networkID~=T and u:GetDistance(N,u:Get2D(bb.pos))<2000)then n(X,bb)end end end end for Y,Z in pairs(X)do local ab=false local bb=u:Get2D(Z.pos)local cb,db=u:ClosestPointOnLineSegment(bb,N,O)if db and u:IsInRange(bb,cb,R+15+Z.boundingRadius)then ab=true elseif Z.pathing.hasMovePath then bb=u:Get2D(Z:GetPrediction(P,Q))cb,db=u:ClosestPointOnLineSegment(bb,N,O)if db and u:IsInRange(bb,cb,R+15+Z.boundingRadius)then ab=true end end if ab then n(V,Z)W=W+1 end end return U,V,W end z={}function z:GetPrediction(N,O,P,Q,R,S)local T,U=N.networkID,N.ms if not S then local bb=N.pathing.hasMovePath if not bb then return u:Get2D(N.pos)end local cb=v:GetPath(N)if#cb<=1 then return u:Get2D(N.pos)end local db=Q+s:GetLatency()+s:GetExtraDelay()local eb=v:CutPath(cb,U*db)if P==d then return eb[1]end local fb,gb=v:GetPredictedPath(O,P,U,cb)if fb then return fb[#fb]end return cb[#cb]end w:OnPrediction(N)local V=w.Visible[T]if V.visible then if GetTickCount()<V.visibleTick+0.5 then return nil,nil,-1 end elseif GetTickCount()>V.invisibleTick+1 then return nil,nil,-1 end local W=w.Waypoints[T]if W.moving and#W.path<=1 then return nil,nil,-1 end if not W.moving then local bb=u:Get2D(N.pos)return bb,bb,Q+u:GetDistance(bb,O)/P end if W.dashing then local bb=W.pos return bb,bb,Q+u:GetDistance(bb,O)/P end local X=Q+s:GetLatency()+s:GetExtraDelay()if P==d then local bb=v:CutPath(W.path,U*X)local cb=v:CutPath(W.path,(U*X)-R)return bb[1],cb[1],Q end local Y,Z=v:GetPredictedPath(O,P,U,v:CutPath(W.path,U*X))if Y then local bb=v:CutPath(v:ReversePath(Y),R)return Y[#Y],bb[1],Q+u:GetDistance(Y[#Y],O)/P end local ab=W.path[#W.path]return ab,ab,Q+u:GetDistance(ab,O)/P end function z:SpellPrediction(N)local O={}do O.Collision,O.MaxCollision,O.CollisionTypes=false,0,{0,3}if(N.Collision~=nil)then O.Collision=N.Collision end if(N.MaxCollision~=nil)then O.MaxCollision=N.MaxCollision end if(N.CollisionTypes~=nil)then O.CollisionTypes=N.CollisionTypes end O.Type,O.Speed,O.Range,O.Delay,O.Radius,O.UseBoundingRadius=J,d,d,0,1,false if(N.Type~=nil)then O.Type=N.Type end if(N.Speed~=nil)then O.Speed=N.Speed end if(N.Range~=nil)then O.Range=N.Range end if(N.Delay~=nil)then O.Delay=N.Delay end if(N.Radius~=nil)then O.Radius=N.Radius end if(N.UseBoundingRadius or(N.UseBoundingRadius==nil and O.Type==J))then O.UseBoundingRadius=true end end function O:ResetOutput()self.HitChance=0 self.CastPosition=nil self.UnitPosition=nil self.TimeToHit=0 self.CollionableObjects={}end function O:GetOutput()self.TargetIsHero=self.Target.type==Obj_AI_Hero self.RealRadius=self.UseBoundingRadius and self.Radius+self.Target.boundingRadius or self.Radius self.UnitPosition,self.CastPosition,self.TimeToHit=z:GetPrediction(self.Target,self.Source,self.Speed,self.Delay,self.RealRadius,self.TargetIsHero)end function O:HighHitChance(P,Q)local R,S,T,U=w.Waypoints[self.Target.networkID],self.Target.pathing,GetTickCount(),o.Timer()if not self.Target.visible then return false end if R.moving then if T<R.tick+150 then return true end if T>R.tick+1000 and v:GetLenght(R.path)>1000 then return true end return false end if T-R.stoptick<50 then return true end if T-R.stoptick>1000 then return true end if Q-0.05>U then return true end if P-0.05>U then return true end return false end function O:IsCollision()local P,Q,R=y:GetCollision(self.Source,self.CastPosition,self.Speed,self.Delay,self.Radius,self.CollisionTypes,self.Target.networkID)if P or R>self.MaxCollision then self.CollionableObjects=Q return true end return false end function O:IsInRange()self.MyHeroPos=u:Get2D(myHero.pos)if u:IsInRange(self.Type==K and self.CastPosition or self.UnitPosition,self.MyHeroPos,self.Range)then self.IsOnScreen=u:Get3D(self.CastPosition):To2D().onScreen if not self.IsOnScreen and self.Type==K then return false end return true end return false end function O:CanHit(P)P=P or G if self.UnitPosition==nil or self.CastPosition==nil then self.HitChance=0 return false end self.HitChance=G if self.TargetIsHero then local R,S,T,U=t:GetDuration(self.Target)if U~=0 then self.HitChance=0 return false end if R>0 then if self.TimeToHit+0.02<R+self.RealRadius/self.Target.ms then self.HitChance=I end end if self.HitChance==G and self:HighHitChance(S,T)then self.HitChance=H end end if self.HitChance<P then return false end if self.Range~=d and not self:IsInRange()then return false end if self.Collision and self:IsCollision()then return false end if not u:VectorsEqual(self.PosTo,u:Get2D(self.Target.posTo),50)then return false end if os.clock()-self.StartTime>0.005 then return false end if not self.IsOnScreen then self.CastPosition=u:Extended(self.MyHeroPos,u:Normalized(self.CastPosition,self.MyHeroPos),800)end local Q=self.Target.pos.y self.CastPosition.y=Q self.UnitPosition.y=Q return true end function O:GetPrediction(P,Q)self.Target=P self.Source=u:Get2D(Q)self.PosTo=u:Get2D(P.posTo)self.StartTime=os.clock()self:ResetOutput()self:GetOutput()end function O:GetAOEPrediction(P)local Q={}local R=x:GetEnemyHeroes()for U=1,#R do local V=R[U]if not SDK.ObjectManager:IsHeroImmortal(V)then self:GetPrediction(V,P)if self:CanHit(G)then n(Q,{V,self.HitChance,self.TimeToHit,self.CastPosition,self.UnitPosition})end end end local S={}local T=self.Type==K for U=1,#Q do local V=Q[U]local W=1 local X=0 local Y=V[4]for Z=1,#Q do if U~=Z then local ab local bb=Q[Z][5]if T then ab=u:GetDistance(Y,bb)else local cb,db=u:ClosestPointOnLineSegment(bb,self.Source,Y)ab=u:GetDistance(cb,bb)end if ab<self.RealRadius then W=W+1 X=X+ab end end end n(S,{Count=W,Distance=X,Unit=V[1],HitChance=V[2],TimeToHit=V[3],CastPosition=Y})end return S end return O end _G.GGPrediction={COLLISION_MINION=A,COLLISION_ALLYHERO=B,COLLISION_ENEMYHERO=C,COLLISION_YASUOWALL=D,HITCHANCE_IMPOSSIBLE=E,HITCHANCE_COLLISION=F,HITCHANCE_NORMAL=G,HITCHANCE_HIGH=H,HITCHANCE_IMMOBILE=I,SPELLTYPE_LINE=J,SPELLTYPE_CIRCLE=K,SPELLTYPE_CONE=L,}function GGPrediction:GetPrediction(N,O,P,Q,R)return z:GetPrediction(N,u:Get2D(O),P,Q,R,N.type==Obj_AI_Hero)end function GGPrediction:GetCollision(N,O,P,Q,R,S,T)return y:GetCollision(N,O,P,Q,R,S,T)end function GGPrediction:SpellPrediction(N)return z:SpellPrediction(N)end function GGPrediction:ClosestPointOnLineSegment(N,O,P)return u:ClosestPointOnLineSegment(N,O,P)end function GGPrediction:IsInRange(N,O,P)return u:IsInRange(N,O,P)end function GGPrediction:GetImmobileDuration(N)return t:GetDuration(N)end function GGPrediction:FindAngle(N,O,P)return u:FindAngle(N,O,P)end function GGPrediction:GetDistance(N,O)return u:GetDistance(N,O)end function GGPrediction:IsInRange(N,O,P)return u:IsInRange(N,O,P)end function GGPrediction:CircleCircleIntersection(N,O,P,Q)return u:CircleCircleIntersection(N,O,P,Q)end
